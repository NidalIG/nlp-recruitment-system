# quiz_module.py - G√©n√©rateur de Quiz de Recrutement
import json
import google.generativeai as genai
from typing import Dict, List, Literal
from dataclasses import dataclass
from datetime import datetime

# Configuration de l'API Gemini
GEMINI_API_KEY = "AIzaSyDTuizxjEyc9WdgvIcJmONBqVPKg6A0mGE"  
genai.configure(api_key=GEMINI_API_KEY)

generation_config = {
    "temperature": 0.7,
    "top_p": 0.8,
    "top_k": 40,
    "max_output_tokens": 2048,
}

model = genai.GenerativeModel(
    'gemini-1.5-flash',
    generation_config=generation_config
)

@dataclass
class QuizQuestion:
    """Structure d'une question de quiz"""
    question: str
    options: List[str]
    correct_answer: int
    explanation: str
    skill_area: str
    difficulty: str

@dataclass
class Quiz:
    """Structure compl√®te d'un quiz"""
    title: str
    description: str
    level: str
    questions: List[QuizQuestion]
    estimated_duration: int

@dataclass
class UserAnswer:
    """Structure pour stocker les r√©ponses de l'utilisateur"""
    question_index: int
    selected_option: int
    is_correct: bool = False

@dataclass
class QuizResults:
    """R√©sultats du quiz"""
    user_answers: List[UserAnswer]
    score: int
    total_questions: int
    percentage: float

class QuizGenerator:
    """G√©n√©rateur de quiz simplifi√© - utilise directement le profil JSON"""
    
    def __init__(self, model):
        self.model = model
    
    def create_prompt_from_profile(self, user_profile: Dict, 
                                  level: Literal["d√©butant", "interm√©diaire", "avanc√©"], 
                                  num_questions: int = 10) -> str:
        """
        Cr√©e un prompt simple bas√© directement sur le profil JSON extrait du CV
        """
        
        # Extraction simple des informations
        name = user_profile.get('name', 'Candidat')
        skills = user_profile.get('skills', [])
        education = user_profile.get('education', [])
        experience = user_profile.get('experience', [])
        
        # D√©finition des niveaux
        level_descriptions = {
            "d√©butant": "Questions fondamentales, concepts de base, syntaxe simple",
            "interm√©diaire": "Applications pratiques, r√©solution de probl√®mes moyens, int√©gration de concepts",
            "avanc√©": "Optimisation, architecture, cas complexes, bonnes pratiques avanc√©es"
        }
        
        # Construction du prompt simple et direct
        prompt = f"""
        Vous √™tes un expert en recrutement technique. G√©n√©rez un quiz de {num_questions} questions pour √©valuer ce candidat.

        PROFIL CANDIDAT (extrait du CV):
        - Nom: {name}
        - Comp√©tences: {', '.join(skills)}
        - Formation: {education[0].get('degree', 'Non sp√©cifi√©e') if education else 'Non sp√©cifi√©e'}
        - Exp√©rience: {len(experience)} poste(s)
        
        NIVEAU DEMAND√â: {level.upper()}
        {level_descriptions[level]}

        INSTRUCTIONS:
        1. Cr√©ez {num_questions} questions QCM (4 options chacune)
        2. Basez-vous sur les comp√©tences list√©es: {', '.join(skills)}
        3. Adaptez la difficult√© au niveau {level}
        4. Variez les domaines selon les comp√©tences du candidat
        5. Questions pratiques et th√©oriques m√©lang√©es

        FORMAT R√âPONSE (JSON uniquement, sans autre texte):
        {{
            "quiz_title": "Quiz {level.title()} - √âvaluation Technique",
            "quiz_description": "Quiz adapt√© au profil de {name}",
            "estimated_duration": {int(num_questions * 1.5)},
            "questions": [
                {{
                    "id": 1,
                    "question": "Question bas√©e sur les comp√©tences du profil",
                    "options": ["A) Option 1", "B) Option 2", "C) Option 3", "D) Option 4"],
                    "correct_answer": 0,
                    "explanation": "Explication d√©taill√©e",
                    "skill_area": "Comp√©tence du profil concern√©e",
                    "difficulty": "{level}"
                }}
            ]
        }}
        """
        
        return prompt
    
    def extract_json_from_response(self, response_text: str) -> dict:
        """Extrait le JSON de la r√©ponse"""
        import re
        
        # Chercher le JSON dans la r√©ponse
        json_pattern = r'\{.*\}'
        json_match = re.search(json_pattern, response_text, re.DOTALL)
        
        if json_match:
            json_str = json_match.group(0)
            try:
                return json.loads(json_str)
            except json.JSONDecodeError:
                pass
        
        # Nettoyage si n√©cessaire
        cleaned_text = response_text.strip()
        if cleaned_text.startswith('```json'):
            cleaned_text = cleaned_text[7:]
        if cleaned_text.endswith('```'):
            cleaned_text = cleaned_text[:-3]
        
        return json.loads(cleaned_text.strip())
    
    def generate_quiz(self, user_profile: Dict, 
                     level: Literal["d√©butant", "interm√©diaire", "avanc√©"], 
                     num_questions: int = 10) -> Quiz:
        """G√©n√®re un quiz directement √† partir du profil JSON"""
        
        try:
            # Cr√©ation du prompt simple
            prompt = self.create_prompt_from_profile(user_profile, level, num_questions)
            
            print(f"üì° G√©n√©ration du quiz niveau {level} pour {user_profile.get('name', 'Candidat')}...")
            
            # Appel API
            response = self.model.generate_content(prompt)
            
            # Parsing JSON
            quiz_data = self.extract_json_from_response(response.text)
            
            # Cr√©ation des objets Question
            questions = []
            for q_data in quiz_data['questions']:
                question = QuizQuestion(
                    question=q_data['question'],
                    options=q_data['options'],
                    correct_answer=q_data['correct_answer'],
                    explanation=q_data['explanation'],
                    skill_area=q_data['skill_area'],
                    difficulty=q_data['difficulty']
                )
                questions.append(question)
            
            # Cr√©ation du quiz final
            quiz = Quiz(
                title=quiz_data['quiz_title'],
                description=quiz_data['quiz_description'],
                level=level,
                questions=questions,
                estimated_duration=quiz_data['estimated_duration']
            )
            
            print(f"‚úÖ Quiz cr√©√©: {len(quiz.questions)} questions")
            return quiz
            
        except Exception as e:
            print(f"‚ùå Erreur: {str(e)}")
            return None

class QuizEvaluator:
    """Classe pour √©valuer les r√©ponses du quiz avec v√©rification Gemini"""
    
    def __init__(self, model=None):
        """Initialise l'√©valuateur avec le mod√®le Gemini"""
        self.model = model or genai.GenerativeModel('gemini-1.5-flash')
    
    def verify_question_with_gemini(self, question: QuizQuestion) -> dict:
        """V√©rifie une question avec Gemini pour s'assurer de la justesse"""
        
        prompt = f"""
        V√©rifiez cette question de quiz et sa r√©ponse :
        
        Question: {question.question}
        Options: {question.options}
        R√©ponse marqu√©e comme correcte: {question.options[question.correct_answer]} (index {question.correct_answer})
        Explication fournie: {question.explanation}
        
        INSTRUCTIONS:
        1. Calculez ou analysez la vraie r√©ponse correcte
        2. V√©rifiez si l'index de r√©ponse correcte est bon
        3. V√©rifiez si l'explication est coh√©rente avec la r√©ponse
        
        R√©pondez au format JSON UNIQUEMENT:
        {{
            "is_correct_answer_valid": true/false,
            "correct_answer_index": index_correct,
            "correct_option_text": "texte de la bonne r√©ponse",
            "explanation_is_valid": true/false,
            "corrected_explanation": "explication corrig√©e si n√©cessaire",
            "verification_details": "d√©tails de votre v√©rification"
        }}
        """
        
        try:
            response = self.model.generate_content(prompt)
            # Nettoyage de la r√©ponse pour extraire le JSON
            response_text = response.text.strip()
            if response_text.startswith('```json'):
                response_text = response_text[7:-3]
            elif response_text.startswith('```'):
                response_text = response_text[3:-3]
            
            return json.loads(response_text)
        except Exception as e:
            print(f" Erreur lors de la v√©rification Gemini: {e}")
            return {
                "is_correct_answer_valid": True,
                "correct_answer_index": question.correct_answer,
                "correct_option_text": question.options[question.correct_answer],
                "explanation_is_valid": True,
                "corrected_explanation": question.explanation,
                "verification_details": "V√©rification √©chou√©e, valeurs originales conserv√©es"
            }
    
    def generate_detailed_explanation(self, question: QuizQuestion, user_answer_index: int, is_correct: bool) -> str:
        """G√©n√®re une explication d√©taill√©e avec Gemini"""
        
        user_answer = question.options[user_answer_index] if user_answer_index >= 0 else "Aucune r√©ponse"
        correct_answer = question.options[question.correct_answer]
        
        prompt = f"""
        G√©n√©rez une explication p√©dagogique pour cette question de quiz :
        
        Question: {question.question}
        R√©ponse de l'utilisateur: {user_answer}
        R√©ponse correcte: {correct_answer}
        R√©sultat: {" Correct" if is_correct else " Incorrect"}
        
        Cr√©ez une explication qui :
        1. Explique pourquoi la r√©ponse correcte est bonne
        2. Si l'utilisateur s'est tromp√©, explique pourquoi sa r√©ponse est incorrecte
        3. Donne des conseils p√©dagogiques
        4. Reste bienveillante et constructive
        
        Format souhait√©:
         Explication: [votre explication d√©taill√©e]
        """
        
        try:
            response = self.model.generate_content(prompt)
            return response.text.strip()
        except Exception as e:
            print(f" Erreur g√©n√©ration explication: {e}")
            return f" Explication: {question.explanation}"
    
    @staticmethod
    def evaluate_answers(quiz: Quiz, user_answers: Dict[int, int]) -> QuizResults:
        """√âvalue les r√©ponses de l'utilisateur avec v√©rification Gemini"""
        
        # Cr√©er une instance d'√©valuateur pour utiliser Gemini
        evaluator = QuizEvaluator()
        
        results = []
        score = 0
        corrections_made = 0
        
        print(" V√©rification des questions avec Gemini...")
        
        for i, question in enumerate(quiz.questions):
            # V√©rification de la question avec Gemini
            verification = evaluator.verify_question_with_gemini(question)
            
            # Si Gemini d√©tecte une erreur, on corrige
            if not verification["is_correct_answer_valid"]:
                print(f" Question {i+1}: Correction d√©tect√©e par Gemini")
                print(f"   Ancienne r√©ponse: {question.options[question.correct_answer]}")
                print(f"   Nouvelle r√©ponse: {verification['correct_option_text']}")
                
                # Mettre √† jour la question
                question.correct_answer = verification["correct_answer_index"]
                if not verification["explanation_is_valid"]:
                    question.explanation = verification["corrected_explanation"]
                
                corrections_made += 1
            
            # √âvaluation de la r√©ponse utilisateur
            user_answer_index = user_answers.get(i, -1)
            is_correct = (user_answer_index == question.correct_answer)
            
            if is_correct:
                score += 1
            
            # G√©n√©rer une explication d√©taill√©e
            detailed_explanation = evaluator.generate_detailed_explanation(
                question, user_answer_index, is_correct
            )
                
            results.append(UserAnswer(
                question_index=i,
                selected_option=user_answer_index,
                is_correct=is_correct
            ))
        
        percentage = (score / len(quiz.questions)) * 100 if quiz.questions else 0
        
        if corrections_made > 0:
            print(f" {corrections_made} question(s) corrig√©e(s) automatiquement par Gemini")
        
        return QuizResults(
            user_answers=results,
            score=score,
            total_questions=len(quiz.questions),
            percentage=percentage
        )
    
    def display_detailed_results(self, quiz: Quiz, results: QuizResults, user_answers: Dict[int, int]):
        """Affiche les r√©sultats d√©taill√©s avec explications Gemini"""
        
        print("=" * 80)
        print(f" R√âSULTATS DU QUIZ: {quiz.title}")
        print(f"Score: {results.score}/{results.total_questions} ({results.percentage:.1f}%)")
        print("=" * 80)
        
        for i, (question, result) in enumerate(zip(quiz.questions, results.user_answers)):
            print(f"\n Question {i+1}: {question.question}")
            
            # Affichage des options avec marquage
            for j, option in enumerate(question.options):
                marker = ""
                if j == question.correct_answer:
                    marker = " ‚úÖ"
                elif j == result.selected_option:
                    marker = " ‚ùå" if not result.is_correct else " ‚úÖ"
                
                print(f"   {option}{marker}")
            
            # R√©sultat
            if result.is_correct:
                print("üéâ Votre r√©ponse est CORRECTE !")
            else:
                user_answer = question.options[result.selected_option] if result.selected_option >= 0 else "Aucune r√©ponse"
                print(f"‚ùå Votre r√©ponse: {user_answer}")
                print(f"‚úÖ R√©ponse correcte: {question.options[question.correct_answer]}")
            
            # Explication d√©taill√©e g√©n√©r√©e par Gemini
            detailed_explanation = self.generate_detailed_explanation(
                question, result.selected_option, result.is_correct
            )
            print(detailed_explanation)
            print("-" * 60)

def display_quiz(quiz: Quiz):
    """Affiche le quiz"""
    if not quiz:
        print("‚ùå Aucun quiz √† afficher")
        return
    
    print("=" * 60)
    print(f"üéØ {quiz.title}")
    print(f"üìã {quiz.description}")
    print(f"‚è±Ô∏è  Dur√©e: {quiz.estimated_duration} minutes")
    print("=" * 60)
    
    for i, question in enumerate(quiz.questions, 1):
        print(f"\n‚ùì Question {i}: {question.question}")
        print(f"üéØ Comp√©tence: {question.skill_area}")
        
        for option in question.options:
            print(f"   {option}")
        
        print(f"‚úÖ R√©ponse: {question.options[question.correct_answer]}")
        print(f"üí° {question.explanation}")
        print("-" * 40)

def save_quiz_to_json(quiz: Quiz, filename: str) -> bool:
    """Sauvegarde le quiz"""
    if not quiz:
        return False
    
    quiz_dict = {
        "title": quiz.title,
        "description": quiz.description,
        "level": quiz.level,
        "estimated_duration": quiz.estimated_duration,
        "generated_at": datetime.now().isoformat(),
        "questions": [
            {
                "question": q.question,
                "options": q.options,
                "correct_answer": q.correct_answer,
                "explanation": q.explanation,
                "skill_area": q.skill_area,
                "difficulty": q.difficulty
            }
            for q in quiz.questions
        ]
    }
    
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(quiz_dict, f, ensure_ascii=False, indent=2)
    
    return True